[
    {
        "id": "12519283120209c6",
        "type": "tab",
        "label": "fusionForecast",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "5aa63f159f798346",
        "type": "influxdb",
        "hostname": "influxdb",
        "port": "8086",
        "protocol": "http",
        "database": "default",
        "name": "InfluxDB Fusion",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://influxdb:8086",
        "timeout": "10",
        "rejectUnauthorized": false
    },
    {
        "id": "4c335a0864f6c70c",
        "type": "global-config",
        "env": [],
        "modules": {
            "node-red-contrib-influxdb": "0.7.0"
        }
    },
    {
        "id": "2a369916e3b417c9",
        "type": "inject",
        "z": "12519283120209c6",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "1800",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 210,
        "y": 180,
        "wires": [
            [
                "39ca3497c310e735"
            ]
        ]
    },
    {
        "id": "39ca3497c310e735",
        "type": "template",
        "z": "12519283120209c6",
        "name": "Config",
        "field": "config",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "{\n    \"consumer\": {\n        \"min_soc\": 20,\n        \"soc_hysteresis\": 20.0,\n        \"min_runtime_minutes\": 30,\n        \"battery_capacity_kwh\": 4.5,\n        \"pv_peak_power_w\": 5200.0,\n        \"reserve_kwh\": 2.0,\n        \"consumer_power_w\": 2000.0,\n        \"base_load_w\": 400.0,\n        \"battery_efficiency\": 0.85,\n        \"use_damping_factor\": true,\n        \"allow_battery_support\": true\n    }\n}",
        "output": "json",
        "x": 450,
        "y": 180,
        "wires": [
            [
                "47a5586e2aa68dcd",
                "01f5957c7daa1475"
            ]
        ]
    },
    {
        "id": "0afd6ef079298c4f",
        "type": "function",
        "z": "12519283120209c6",
        "name": "Logik",
        "func": "/**\n * Control Logic for Smart Solar Consumer\n * ==========================================================\n * This logic determines if a consumer (load) should be switched ON based on:\n * 1. Current Battery SoC (State of Charge)\n * 2. Solar Forecast Data (InfluxDB)\n * 3. Calculated Energy Surplus\n * 4. Safety Constraints & Hysteresis Logic\n *\n * Inputs:\n * - msg.config: Configuration object (params like min_soc, capacity...)\n * - msg.payload: Array of InfluxDB data points (SoC + Forecast + Production)\n * - context.lastState: Previous switch state (1=OFF, 0=ON)\n * - context.lowBatLock: Safety lock that activates if battery crashes while load is ON\n *\n * Outputs:\n * - msg.payload: 0 (ON) or 1 (OFF)\n * - msg.debug_calc: Detailed calculation info for debugging\n * - node.status: Visual ring/dot indicator\n */\nif (!msg.config || !msg.config.consumer) {\n    node.error(\"Critical Error: No configuration received!\");\n    node.status({fill: \"red\", shape: \"ring\", text: \"Missing Config\"});\n    return null; \n}\n\n// --- CONFIGURATION VALIDATION ---\nfunction requireVal(val, name) {\n    const num = Number(val);\n    if (isNaN(num) || num < 0) {\n        throw new Error(`Invalid value for '${name}': ${val}`);\n    }\n    return num;\n}\n\nconst rawConf = msg.config.consumer || {};\nlet conf;\n\ntry {\n    conf = {\n        min_soc: requireVal(rawConf.min_soc, \"min_soc\"),\n        soc_hysteresis: Number(rawConf.soc_hysteresis),\n        min_runtime_minutes: requireVal(rawConf.min_runtime_minutes, \"min_runtime_minutes\"),\n        battery_capacity_kwh: requireVal(rawConf.battery_capacity_kwh, \"battery_capacity_kwh\"),\n        pv_peak_power_w: requireVal(rawConf.pv_peak_power_w, \"pv_peak_power_w\"),\n        reserve_kwh: requireVal(rawConf.reserve_kwh, \"reserve_kwh\"),\n        consumer_power_w: requireVal(rawConf.consumer_power_w, \"consumer_power_w\"),\n        base_load_w: requireVal(rawConf.base_load_w, \"base_load_w\"),\n        battery_efficiency: requireVal(rawConf.battery_efficiency, \"battery_efficiency\"),\n        use_damping_factor: rawConf.use_damping_factor !== undefined ? Boolean(rawConf.use_damping_factor) : false,\n        allow_battery_support: rawConf.allow_battery_support !== undefined ? Boolean(rawConf.allow_battery_support) : true\n    };\n} catch (error) {\n    node.error(error.message);\n    node.status({fill: \"grey\", shape: \"ring\", text: \"Config Error\"});\n    return null; \n}\n\n// --- HYSTERESIS CONSTANTS ---\n// This is used to release the lock after a batterie crash\nconst RECOVERY_SOC = Math.min(conf.min_soc + conf.soc_hysteresis, 100);\n\n// --- LOAD CONTEXT (MEMORY) ---\nlet lastState = context.get('lastState');\nif (lastState === undefined) lastState = 1; // Default: OFF (1)\n\nlet lowBatLock = context.get('lowBatLock');\nif (lowBatLock === undefined) lowBatLock = false;\n\n// --- EXTRACT DATA FROM INFLUX ---\nlet currentSoc = -1; \nlet fullForecastList = [];\nlet productionList = [];\nlet dataValid = false;\n\nif (Array.isArray(msg.payload)) {\n    const socObj = msg.payload.find(r => r._field === \"type_soc\");\n    if (socObj && socObj._value !== undefined) {\n        currentSoc = Number(socObj._value);\n    }\n\n    fullForecastList = msg.payload.filter(r => \n        r._field === \"type_forecast\" && r._time && r._value !== null\n    );\n    \n    // Extract Actual Production (History) for Damping Calculation\n    productionList = msg.payload.filter(r => \n        r._field === \"type_production\" && r._time && r._value !== null\n    );\n\n    try {\n        const timeSort = (a, b) => new Date(a._time).getTime() - new Date(b._time).getTime();\n        fullForecastList.sort(timeSort);\n        productionList.sort(timeSort);\n    } catch (e) {\n        node.warn(\"Error sorting: \" + e.message);\n    }\n    \n    if (currentSoc !== -1) dataValid = true;\n}\n\n// --- UPDATE LOCK STATE (RESET) ---\nif (dataValid && currentSoc >= RECOVERY_SOC) {\n    lowBatLock = false;\n}\n\n// --- DAMPING FACTOR CALCULATION ---\n// Concept: \"Real-Time Forecast Correction\"\n// We compare the ACTUAL production vs. the FORECAST since sunrise to calculate a \"Performance Factor\".\n// If the sun is stronger than predicted (Factor > 1.0), we scale UP the future forecast.\n// If it is cloudier than predicted (Factor < 1.0), we scale DOWN the future forecast.\n// This allows the system to react dynamically to intraday weather changes (e.g. fog clearing up earlier).\nconst nowMs = Date.now();\nlet dampingFactor = 1.0;\nlet sumForecastPast = 0;\nlet sumProductionPast = 0;\n\nlet dampingReason = \"OK\";\nlet matchCount = 0;\n\nif (conf.use_damping_factor) {\n    if (productionList.length > 0 && fullForecastList.length > 0) {\n        for (let prod of productionList) {\n            const pTime = new Date(prod._time).getTime();\n            if (pTime > nowMs) continue; // Skip future\n\n            // Find matching forecast (within 7.5 mins)\n            const match = fullForecastList.find(f => Math.abs(new Date(f._time).getTime() - pTime) < 7.5 * 60 * 1000);\n            \n            if (match) {\n                const fVal = Number(match._value);\n                const pVal = Number(prod._value); // Assumed Watts\n                \n                // Only compare when significant power is expected (> 50% of Base Load)\n                // This implicitly filters for \"since sunrise\"\n                if (fVal > conf.base_load_w / 2.0) { \n                     // Weight recent data more strongly: Exponential decay of \"relevance\" (Half-Life 1h)\n                     // Matches the decay logic used for future forecast adjustment\n                     // Example:\n                     // - T-00 min: Weight 100% (1.00) -> Full Impact\n                     // - T-30 min: Weight ~71% (0.71)\n                     // - T-60 min: Weight  50% (0.50) -> Half Impact\n                     // - T-2h:     Weight  25% (0.25)\n                     //\n                     // Why?\n                     // We want to react fast to changing weather (e.g., fog clearing up).\n                     // Data from 2 hours ago is \"historically correct\" but \"irrelevant\" for the current trend.\n                     // By fading out old data, the \"Interpretation\" follows the \"Reality\" much closer.\n                     const ageHours = Math.max(0, (nowMs - pTime) / (3600 * 1000));\n                     const weight = Math.pow(0.5, ageHours / 1.0);\n\n                     sumForecastPast += fVal * weight;\n                     sumProductionPast += pVal * weight;\n                     matchCount++;\n                }\n            }\n        }\n\n        // Only apply if we have enough accumulated sun-hours data.\n        // Adjusted for Weighting: Since we dampen older values, the sum is smaller.\n        // Threshold approx 3.0 units of \"Full Weight Base Load\" (approx 4-6 real samples).\n        if (sumForecastPast >  conf.base_load_w  / 2.0 * 3.0) { \n            dampingFactor = sumProductionPast / sumForecastPast;\n            // Safety Clamping (0.75x to 1.5x) to prevent extreme scaling\n            dampingFactor = Math.max(0.75, Math.min(dampingFactor, 1.5));\n        } else {\n            dampingReason = \"Insufficient Sun-Hours (Sums too low)\";\n        }\n    } else {\n        if (productionList.length === 0 && fullForecastList.length === 0) dampingReason = \"No Data (Prod & Fcst)\";\n        else if (productionList.length === 0) dampingReason = \"No Production Data\";\n        else if (fullForecastList.length === 0) dampingReason = \"No Forecast Data\";\n    }\n} else {\n    dampingReason = \"Disabled by Config\";\n}\n\n// --- FILTER & ADJUST FORECAST ---\n// 1. Keep only FUTURE items for planning (from now onwards)\n// 2. Apply Damping Factor\nlet forecastList = [];\nlet currentForecastWatts = 0;\n\nif (fullForecastList.length > 0) {\n    // Include current 15-min window\n    const activeWindowStart = nowMs - (15 * 60 * 1000);\n    \n    forecastList = fullForecastList\n        .filter(f => new Date(f._time).getTime() >= activeWindowStart)\n        .map(item => {\n            // Apply Damping Factor with Time Decay\n            // Formula: Weight = 0.5 ^ (hours_future / 2)\n            // Meaning: 100% influence now, 50% in 2h, 25% in 4h, ...\n            let adjustedForecastValue = Number(item._value);\n            \n            if (conf.use_damping_factor) {\n                 const itemTime = new Date(item._time).getTime();\n                 \n                 // Difference in hours between NOW and this future forecast point\n                 // (Math.max to ensure we don't handle negative past times weirdly, although they are filtered)\n                 const diffHours = Math.max(0, (itemTime - nowMs) / (1000 * 60 * 60));\n                 \n                 // --- TIME DECAY LOGIC ---\n                 // We trust the current deviation (Damping Factor) fully for the immediate moment.\n                 // However, weather anomalies (clouds, fog) are often temporary.\n                 // We don't want to scale the forecast 10 hours away based on a cloud right now.\n                 //\n                 // Formula: Weight = 0.5 ^ (hours / 1.0)\n                 // This is an \"Exponential Decay\" with a Half-Life of 1 hour.\n                 // - T+0h: Weight 100% -> Full influence of Damping Factor\n                 // - T+1h: Weight  50% -> Half influence\n                 // - T+2h: Weight  25% -> Quarter influence\n                 // - T+4h: Weight   6% -> Nearly back to original Forecast (1.0)\n                 const decayWeight = Math.pow(0.5, diffHours / 1.0);\n                 \n                 // Calculate Effective Factor for this specific time point\n                 // We blend the calculated \"dampingFactor\" with standard \"1.0\" based on the weight.\n                 const effectiveFactor = 1.0 + ((dampingFactor - 1.0) * decayWeight);\n                 \n                 // Limit the scaled value to the physical maximum of the PV system\n                 adjustedForecastValue = Math.min(adjustedForecastValue * effectiveFactor, conf.pv_peak_power_w);\n            }\n            \n            return { ...item, _value: adjustedForecastValue };\n        });\n\n    if (forecastList.length > 0) {\n        currentForecastWatts = Number(forecastList[0]._value);\n    }\n}\n\n// Prepare debug object\nlet debugInfo = {\n    state: \"INIT\",\n    soc: currentSoc,\n    config_used: conf,\n    low_bat_lock_active: lowBatLock,\n    hysteresis_recovery_target: RECOVERY_SOC,\n    current_forecast_w: currentForecastWatts, \n    damping_factor: dampingFactor.toFixed(2),\n    past_analysis: `Matches:${matchCount} | Prod:${sumProductionPast.toFixed(0)} vs Fcst:${sumForecastPast.toFixed(0)} (${dampingReason})`,\n    solar_gain_kwh: 0,\n    base_loss_kwh: 0,\n    surplus_kwh: 0,\n    required_cycle_kwh: 0,\n    required_cycle_soc_pct: 0, \n    cutoff_reason: \"\",\n    remaining_sun_hours: 0\n};\n\n// --- LOGIC ---\n\nlet switchState = 1; // Default OFF\nlet reason = \"\";\nlet color = \"red\";\n\nif (!dataValid) {\n    reason = \"Error: No Influx Data\";\n    color = \"grey\";\n    debugInfo.state = \"ERROR_NO_DATA\";\n} \nelse {\n    // --- CALCULATION ---\n    let solarKwhSum = 0;\n    let baseLoadKwhSum = 0;\n    let remainingSunHours = 0;\n    let cutoffReason = \"End of DB Forcast data\";\n    \n    // Determine current forecast power and remaining usable sun hours (generation > base load)\n    // const timeStepHours = 0.25; // 0.25h = 15 min // This line was moved from here\n    \n    const timeStepHours = 0.25; // 0.25h = 15 min\n\n    // Loop through forecast data to calculate total expected energy.\n    // We also calculate 'remainingSunHours', but ONLY counting periods where\n    // the generated power is sufficient to cover the house's base load.\n    for (let point of forecastList) {\n        const rawVal = Number(point._value);\n        const generatedWatts = Number(point._value);\n        \n        if (generatedWatts < conf.base_load_w) {\n            cutoffReason = `Night: PV Power < House BaseLoad`;\n            break;\n        }\n\n        const stepEnergy = (generatedWatts * timeStepHours) / 1000;\n        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;\n\n        solarKwhSum += stepEnergy;\n        baseLoadKwhSum += stepBaseLoad;\n        remainingSunHours += timeStepHours;\n    }\n\n    \n    // Factor in a margin for inefficiencies in the PV system and inverter. \n    const BATTERY_EFFICIENCY = conf.battery_efficiency;\n\n    // Current Energy in Battery\n    const currentBatteryEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;\n\n    // Energy required to charge to Target (95%) (including efficiency losses)\n    // We treat 95% SoC as \"Full\" (1.0) for this curve to reach minimum reserve earlier.\n    // Reason: Charging speed drops significantly >95%.\n    const TARGET_SOC_LIMIT = 0.95;\n    const targetCapacityKwh = conf.battery_capacity_kwh * TARGET_SOC_LIMIT;\n    const currentChargeEnergyKwhNeeded = Math.max(0, (targetCapacityKwh - currentBatteryEnergyKwh) / BATTERY_EFFICIENCY);    \n\n    // Projected Energy Outcome (Current + Gain - BaseConsumption)\n    const projectedEnergyEndOfDay = currentBatteryEnergyKwh + (solarKwhSum - baseLoadKwhSum);\n\n    // Dynamic Reserve Logic (Quadratic \"Safe\"):\n    // We keep reserve high for safety, reducing it to minimum (10%) when battery is full.\n    // Curve: Factor = 0.1 + 0.9 * (1 - (EffectiveSoC^2))\n    //\n    // Examples (Formula scaled to 95% as Full):\n    // 0% SoC   -> 1.00 * Reserve (100% Safety)\n    // 30% SoC  -> 0.91 * Reserve\n    // 50% SoC  -> 0.75 * Reserve\n    // 80% SoC  -> 0.36 * Reserve\n    // 95% SoC  -> 0.10 * Reserve (Minimum Safe-Floor reached)\n    // 100% SoC -> 0.10 * Reserve (Clamped)\n    \n    const effectiveSoc = Math.min(1.0, Math.max(0, currentSoc / TARGET_SOC_LIMIT));\n    \n    // Calculate Factor: 1.0 (empty) -> 0.1 (full)\n    const socFactor = 0.1 + (0.9 * (1 - Math.pow(effectiveSoc, 2)));\n    const dynamicReserve = conf.reserve_kwh * socFactor;\n    \n    // Target: Full Battery (with charge losses) + Reserve\n    const targetEnergyEndOfDay = currentBatteryEnergyKwh + currentChargeEnergyKwhNeeded + dynamicReserve;\n\n    // Surplus: What is left after filling battery and keeping reserve?\n    const surplusKwh = projectedEnergyEndOfDay - targetEnergyEndOfDay;\n    \n    // Power consumption of the device in kW\n    const consumerKw = conf.consumer_power_w / 1000;\n\n    // Energy cost for one minimum runtime cycle (e.g. 1 hour run = 2kWh)\n    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);\n\n  \n    // Calculate SoC needed for one cycle using the battery\n    // Example: 1.5kWh needed / 10kWh Battery = 0.15 = 15% SoC needed. \n    // We divide by the battery efficiency to account for losses during discharge.\n    const cycleCostSoc = (cycleCostKwh / conf.battery_capacity_kwh) * 100 /  BATTERY_EFFICIENCY;\n    \n    // Define the Safe Buffer Level:\n    // This represents the minimum SoC we need to feel \"safe\" to turn on the load.\n    // It is the HIGHER value of:\n    // 1. The configured Hysteresis (e.g., 20% above min_soc)\n    // 2. The Energy Cost of one full run cycle (e.g. 15% SoC)\n    // This guarantees that if we switch ON, we have enough battery to finish the job\n    // even if the sun suddenly disappears.\n    // This guarantees that if we switch ON, we have enough battery to finish the job\n    // even if the sun suddenly disappears.\n    // If support is disabled, we only need the hysteresis buffer.\n    const neededBuffer = conf.allow_battery_support ? Math.max(conf.soc_hysteresis, cycleCostSoc) : conf.soc_hysteresis;\n    const requiredSafeBufferSoc = conf.min_soc + neededBuffer;\n    \n    if (requiredSafeBufferSoc > 100) {\n        const err = `Safety Buffer ${requiredSafeBufferSoc.toFixed(1)}% > 100%. Battery too small for consumer_power/min_runtime!`;\n        node.error(err);\n        node.status({fill: \"red\", shape: \"ring\", text: \"Config: Battery too small\"});\n        return null; \n    }\n\n    const SAFE_BUFFER_SOC = requiredSafeBufferSoc;\n\n    debugInfo.state = \"CALCULATED\";\n    debugInfo.current_forecast_w = currentForecastWatts;\n    debugInfo.solar_gain_kwh = solarKwhSum;\n    debugInfo.base_loss_kwh = baseLoadKwhSum;\n    debugInfo.surplus_kwh = surplusKwh;\n    debugInfo.required_cycle_kwh = cycleCostKwh;\n    debugInfo.required_cycle_soc_pct = cycleCostSoc; // Show in Debug\n    debugInfo.cutoff_reason = cutoffReason;\n    debugInfo.remaining_sun_hours = remainingSunHours;\n    debugInfo.dynamic_reserve_kwh = dynamicReserve;\n\n    // Safety: We want at least enough sun hours for 2 full runtime cycles.\n    // If we decide to run in the second-to-last cycle, there is still one cycle left to charge.\n    const MIN_REMAINING_SUN_HOURS = 2 * (conf.min_runtime_minutes / 60);\n\n    // --- DECISION LOGIC ---\n\n    // 1. Battery CRITICAL\n    if (currentSoc <= conf.min_soc) {\n        if (lastState === 0) {\n            lowBatLock = true; \n            debugInfo.state = \"LOW_BATTERY_CRASH\"; \n        } else {\n            debugInfo.state = \"LOW_BATTERY_IDLE\"; \n        }\n\n        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;\n        switchState = 1; // OFF\n        color = \"red\";\n    }\n    // 2. Battery RECOVERING (Lock Active)\n    else if (lowBatLock === true) {\n        reason = `Hysteresis Lock... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;\n        debugInfo.state = \"HYSTERESIS_LOCKED\";\n        switchState = 1; \n        color = \"blue\";\n    }\n    // 3. Safety Guard\n    else if (remainingSunHours <=  MIN_REMAINING_SUN_HOURS) {\n        switchState = 1; \n        color = \"black\";\n        reason = `OFF. Remaining sun too short (${remainingSunHours}h <= ${MIN_REMAINING_SUN_HOURS}h)`;\n        debugInfo.state = \"SAFETY_GUARD_ACTIVE\";\n    }\n    // 4. Primary Check: Is Surplus Enough?\n    else if (surplusKwh >= cycleCostKwh) {\n        \n        // Secondary Check: \"Cloud Buffer\" / Instant Power Logic\n        // Even if we have enough surplus for the whole day, we want to be careful \n        // about running NOW if conditions are marginal.\n        //\n        // Risk: If we turn ON now, but the sun is weak and the battery is low,\n        // we might hit min_soc before the cycle finishes.\n        //\n        // Rule: Only allow switching OFF if:\n        // Current Solar Power is NOT enough to run the device (we are draining battery)\n        // AND\n        // Battery is below our SAFE_BUFFER_SOC (we don't have a buffer to drain)\n        if (conf.allow_battery_support && currentForecastWatts < (conf.consumer_power_w + conf.base_load_w) && currentSoc < SAFE_BUFFER_SOC) {\n            switchState = 1; // OFF\n            color = \"yellow\";\n            reason = `OFF. Filling Battery (${currentForecastWatts.toFixed(0)}W, ${currentSoc.toFixed(1)}% < ${SAFE_BUFFER_SOC.toFixed(1)}%)`;\n            debugInfo.state = \"CURRENT_POWER_AND_SOC_LOW\";\n        } \n        // Do we have enough power for EVERYTHING (Base + Consumer)?\n        else if((conf.base_load_w + conf.consumer_power_w) < currentForecastWatts){\n            switchState = 0; // ON\n            color = \"green\";\n            // If the forecast is higher than the base load + consumer power, we can switch ON\n            reason = `ON. Full Power: ${currentForecastWatts.toFixed(0)}W >= ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W`;\n            debugInfo.state = \"SURPLUS_ENOUGH\";\n        }\n        // Do we have at least enough for Base Load? (Draining battery for consumer)\n        else if(conf.base_load_w < currentForecastWatts){\n            if (conf.allow_battery_support) {\n                switchState = 0; // ON\n                color = \"green\";\n                // If the forecast is higher than the base load, we can switch ON\n                reason = `ON. Battery Support: ${currentForecastWatts.toFixed(0)}W < ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W`;\n                debugInfo.state = \"SURPLUS_DRAINING\";\n            } else {\n                switchState = 1; // OFF\n                color = \"yellow\";\n                reason = `OFF. Battery Support Disabled (${currentForecastWatts.toFixed(0)}W < ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W)`;\n                debugInfo.state = \"BATTERY_SUPPORT_DISABLED\";\n            }\n        }\n        else{\n            switchState = 1; // OFF\n            color = \"yellow\";\n            reason = `OFF. Forecast too low (${currentForecastWatts.toFixed(0)}W < ${conf.base_load_w.toFixed(0)}W)`;\n            debugInfo.state = \"SURPLUS_TOO_LOW\";\n        }\n    } \n    // 5. No Surplus\n    else {\n        switchState = 1; // OFF\n        color = \"yellow\";\n        if (surplusKwh > 0) {\n            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;\n            debugInfo.state = \"SURPLUS_TOO_LOW\";\n        } else {\n            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;\n            debugInfo.state = \"SURPLUS_IS_NEGATIVE\";\n        }\n    }\n}\n\n// --- SAVE STATE ---\ncontext.set('lowBatLock', lowBatLock);\ncontext.set('lastState', switchState);\n\nmsg.payload = switchState;\nmsg.debug_calc = debugInfo;\n\nnode.status({fill: color, shape: \"dot\", text: reason});\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 180,
        "wires": [
            [
                "6ab7663f443db754"
            ]
        ]
    },
    {
        "id": "47a5586e2aa68dcd",
        "type": "influxdb in",
        "z": "12519283120209c6",
        "influxdb": "5aa63f159f798346",
        "name": "Inlfux Query",
        "query": "import \"date\"\nimport \"array\"\n\n// As a precaution, we query until tomorrow morning, but later cut off in the script\nheute_start = date.truncate(t: now(), unit: 1d)\nmorgen_frueh = date.add(d: 24h, to: heute_start)\n\n// 1) SoC with fallback = 0 if bucket \"batterie\" returns no matching data\nsoc_real = from(bucket: \"batterie\")\n  |> range(start: -1h)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"pv\")\n  |> filter(fn: (r) => r[\"_field\"] == \"USOC\")\n  |> last()\n  // Return a fresh record (no record extension) to avoid duplicate/scoped labels\n  |> map(fn: (r) => ({_time: r._time, _field: \"type_soc\", _value: float(v: r._value)}))\n\n// Fallback row used when soc_real is empty\nsoc_fallback = array.from(rows: [\n  {_time: now(), _field: \"type_soc\", _value: 0.0}\n])\n\n// If soc_real exists, it overrides the fallback; otherwise fallback remains\nsoc_stream = union(tables: [soc_fallback, soc_real])\n  |> last()\n\n// 2) Forecast curve (without integral); use 15m mean to reduce point count\nforecast_stream = from(bucket: \"forecast_results\")\n  |> range(start: heute_start, stop: morgen_frueh)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"production_forecast\")\n  |> filter(fn: (r) => r[\"_field\"] == \"power_produced_forecast\")\n  |> aggregateWindow(every: 15m, fn: mean, createEmpty: false)\n  |> map(fn: (r) => ({_time: r._time, _field: \"type_forecast\", _value: float(v: r._value)}))\n\nproduction_stream = from(bucket: \"energy_meter\")\n  |> range(start: -2h, stop: now())\n  |> filter(fn: (r) => r[\"_measurement\"] == \"energy_meter\")\n  |> filter(fn: (r) => r[\"_field\"] == \"production\")\n  |> aggregateWindow(every: 15m, fn: mean, createEmpty: false)\n  |> map(fn: (r) => ({_time: r._time, _field: \"type_production\", _value: float(v: r._value)}))\n\n// 3) Union all streams and keep only the relevant columns\nunion(tables: [soc_stream, forecast_stream, production_stream])\n  |> keep(columns: [\"_time\", \"_field\", \"_value\"])\n",
        "rawOutput": false,
        "precision": "",
        "retentionPolicy": "",
        "org": "fusionforecast",
        "x": 650,
        "y": 60,
        "wires": [
            [
                "0afd6ef079298c4f"
            ]
        ]
    },
    {
        "id": "6ce7f91e48855c4e",
        "type": "json",
        "z": "12519283120209c6",
        "d": true,
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 710,
        "y": 340,
        "wires": [
            [
                "0afd6ef079298c4f"
            ]
        ]
    },
    {
        "id": "01f5957c7daa1475",
        "type": "template",
        "z": "12519283120209c6",
        "d": true,
        "name": "Test Data",
        "field": "payload",
        "fieldType": "msg",
        "format": "handlebars",
        "syntax": "mustache",
        "template": "[\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T00:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T00:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T00:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T01:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T01:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T01:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T01:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T02:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T02:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T02:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T02:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T03:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T03:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T03:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T03:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T04:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T04:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T04:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T04:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T05:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T05:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T05:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T05:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T06:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T06:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T06:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T06:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T07:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T07:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T07:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T07:45:00Z\",\n    \"_value\": 95.61059455821044,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T08:00:00Z\",\n    \"_value\": 303.2641402771337,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T08:15:00Z\",\n    \"_value\": 534.1643499396766,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T08:30:00Z\",\n    \"_value\": 737.1604825937167,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T08:45:00Z\",\n    \"_value\": 947.2227292803489,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T09:00:00Z\",\n    \"_value\": 1146.184586228081,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T09:15:00Z\",\n    \"_value\": 1347.339534019962,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T09:30:00Z\",\n    \"_value\": 1529.3226109084708,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T09:45:00Z\",\n    \"_value\": 1704.1910307676944,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T10:00:00Z\",\n    \"_value\": 1855.2264979531133,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T10:15:00Z\",\n    \"_value\": 1992.9303774566738,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T10:30:00Z\",\n    \"_value\": 2109.737362897025,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T10:45:00Z\",\n    \"_value\": 2215.051928646044,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T11:00:00Z\",\n    \"_value\": 2300.9403615769343,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T11:15:00Z\",\n    \"_value\": 2367.9682115089468,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T11:30:00Z\",\n    \"_value\": 2420.820722109774,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T11:45:00Z\",\n    \"_value\": 2443.119656355366,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T12:00:00Z\",\n    \"_value\": 2447.43343888984,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T12:15:00Z\",\n    \"_value\": 2429.6075768602213,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T12:30:00Z\",\n    \"_value\": 2389.339585976015,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T12:45:00Z\",\n    \"_value\": 2330.3618070730736,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T13:00:00Z\",\n    \"_value\": 2256.292788872389,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T13:15:00Z\",\n    \"_value\": 2157.717515291797,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T13:30:00Z\",\n    \"_value\": 2037.8807876537444,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T13:45:00Z\",\n    \"_value\": 1908.4326390652077,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T14:00:00Z\",\n    \"_value\": 1745.687415632205,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T14:15:00Z\",\n    \"_value\": 1578.74356392299,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T14:30:00Z\",\n    \"_value\": 1391.9956717958862,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T14:45:00Z\",\n    \"_value\": 1181.4346272630523,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T15:00:00Z\",\n    \"_value\": 962.3890642733653,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T15:15:00Z\",\n    \"_value\": 740.3516532682149,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T15:30:00Z\",\n    \"_value\": 528.6929320091674,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T15:45:00Z\",\n    \"_value\": 309.2629011239716,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T16:00:00Z\",\n    \"_value\": 212.07710253464313,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T16:15:00Z\",\n    \"_value\": 189.3981088086466,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T16:30:00Z\",\n    \"_value\": 167.20667743255217,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T16:45:00Z\",\n    \"_value\": 145.19875872897626,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T17:00:00Z\",\n    \"_value\": 123.96329417953984,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T17:15:00Z\",\n    \"_value\": 104.05870132656457,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T17:30:00Z\",\n    \"_value\": 85.9841006415038,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T17:45:00Z\",\n    \"_value\": 70.15342659641078,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T18:00:00Z\",\n    \"_value\": 56.874116624981525,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T18:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T18:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T18:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T19:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T19:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T19:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T19:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T20:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T20:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T20:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T20:45:00Z\",\n    \"_value\": 50.35072819914092,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T21:00:00Z\",\n    \"_value\": 52.965135288867145,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T21:15:00Z\",\n    \"_value\": 54.49536406454331,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T21:30:00Z\",\n    \"_value\": 54.81566629584074,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T21:45:00Z\",\n    \"_value\": 53.91306182543872,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T22:00:00Z\",\n    \"_value\": 51.88328734563504,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T22:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T22:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T22:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T23:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T23:15:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T23:30:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-19T23:45:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 0,\n    \"_time\": \"2026-01-20T00:00:00Z\",\n    \"_value\": 0,\n    \"_field\": \"type_forecast\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T09:15:00Z\",\n    \"_value\": 2201.5714285714284,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T09:30:00Z\",\n    \"_value\": 2357.88,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T09:45:00Z\",\n    \"_value\": 2574.213333333333,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T10:00:00Z\",\n    \"_value\": 2760.44,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T10:15:00Z\",\n    \"_value\": 2926.04,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T10:30:00Z\",\n    \"_value\": 3035.68,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T10:45:00Z\",\n    \"_value\": 3090.68,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T11:00:00Z\",\n    \"_value\": 3198.8533333333335,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 1,\n    \"_time\": \"2026-01-19T11:09:19.511696297Z\",\n    \"_value\": 3247.191489361702,\n    \"_field\": \"type_production\"\n  },\n  {\n    \"result\": \"_result\",\n    \"table\": 2,\n    \"_time\": \"2026-01-19T11:09:16.402Z\",\n    \"_value\": 97,\n    \"_field\": \"type_soc\"\n  }\n]",
        "output": "str",
        "x": 560,
        "y": 340,
        "wires": [
            [
                "6ce7f91e48855c4e"
            ]
        ]
    },
    {
        "id": "6ab7663f443db754",
        "type": "debug",
        "z": "12519283120209c6",
        "name": "debug 1",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1060,
        "y": 180,
        "wires": []
    }
]