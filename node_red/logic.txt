/**
 * Control Logic for Smart Solar Consumer
 * ==========================================================
 * This logic determines if a consumer (load) should be switched ON based on:
 * 1. Current Battery SoC (State of Charge)
 * 2. Solar Forecast Data (InfluxDB)
 * 3. Calculated Energy Surplus
 * 4. Safety Constraints & Hysteresis Logic
 *
 * Inputs:
 * - msg.config: Configuration object (params like min_soc, capacity...)
 * - msg.payload: Array of InfluxDB data points (SoC + Forecast)
 * - context.lastState: Previous switch state (1=OFF, 0=ON)
 * - context.lowBatLock: Safety lock that activates if battery crashes while load is ON
 *
 * Outputs:
 * - msg.payload: 0 (ON) or 1 (OFF)
 * - msg.debug_calc: Detailed calculation info for debugging
 * - node.status: Visual ring/dot indicator
 */
if (!msg.config || !msg.config.consumer) {
    node.error("Critical Error: No configuration received!");
    node.status({fill: "red", shape: "ring", text: "Missing Config"});
    return null; 
}

// --- CONFIGURATION VALIDATION ---
function requireVal(val, name) {
    const num = Number(val);
    if (isNaN(num) || num < 0) {
        throw new Error(`Invalid value for '${name}': ${val}`);
    }
    return num;
}

const rawConf = msg.config.consumer || {};
let conf;

try {
    conf = {
        min_soc: requireVal(rawConf.min_soc, "min_soc"),
        soc_hysteresis: Number(rawConf.soc_hysteresis),
        min_runtime_minutes: requireVal(rawConf.min_runtime_minutes, "min_runtime_minutes"),
        battery_capacity_kwh: requireVal(rawConf.battery_capacity_kwh, "battery_capacity_kwh"),
        reserve_kwh: requireVal(rawConf.reserve_kwh, "reserve_kwh"),
        consumer_power_w: requireVal(rawConf.consumer_power_w, "consumer_power_w"),
        base_load_w: requireVal(rawConf.base_load_w, "base_load_w"),
        forecast_conversion_factor: requireVal(rawConf.forecast_conversion_factor, "forecast_conversion_factor"),
        battery_efficiency: requireVal(rawConf.battery_efficiency, "battery_efficiency") 
    };
} catch (error) {
    node.error(error.message);
    node.status({fill: "grey", shape: "ring", text: "Config Error"});
    return null; 
}

// --- HYSTERESIS CONSTANTS ---
// This is used to release the lock after a batterie crash
const RECOVERY_SOC = Math.min(conf.min_soc + conf.soc_hysteresis, 100);

// --- LOAD CONTEXT (MEMORY) ---
let lastState = context.get('lastState');
if (lastState === undefined) lastState = 1; // Default: OFF (1)

let lowBatLock = context.get('lowBatLock');
if (lowBatLock === undefined) lowBatLock = false;

// --- EXTRACT DATA FROM INFLUX ---
let currentSoc = -1; 
let forecastList = [];
let dataValid = false;

if (Array.isArray(msg.payload)) {
    const socObj = msg.payload.find(r => r._field === "type_soc");
    if (socObj && socObj._value !== undefined) {
        currentSoc = Number(socObj._value);
    }

    forecastList = msg.payload.filter(r => 
        r._field === "type_forecast" && r._time && r._value !== null
    );

    try {
        forecastList.sort((a, b) => new Date(a._time).getTime() - new Date(b._time).getTime());
    } catch (e) {
        node.warn("Error sorting: " + e.message);
    }
    
    if (currentSoc !== -1) dataValid = true;
}

// --- UPDATE LOCK STATE (RESET) ---
if (dataValid && currentSoc >= RECOVERY_SOC) {
    lowBatLock = false;
}

// Prepare debug object
let debugInfo = {
    state: "INIT",
    soc: currentSoc,
    config_used: conf,
    low_bat_lock_active: lowBatLock,
    hysteresis_recovery_target: RECOVERY_SOC,
    current_forecast_w: 0, 
    solar_gain_kwh: 0,
    base_loss_kwh: 0,
    surplus_kwh: 0,
    required_cycle_kwh: 0,
    required_cycle_soc_pct: 0, 
    cutoff_reason: "",
    remaining_sun_hours: 0
};

// --- LOGIC ---

let switchState = 1; // Default OFF
let reason = "";
let color = "red";

if (!dataValid) {
    reason = "Error: No Influx Data";
    color = "grey";
    debugInfo.state = "ERROR_NO_DATA";
} 
else {
    // --- CALCULATION ---
    let solarKwhSum = 0;
    let baseLoadKwhSum = 0;
    let remainingSunHours = 0;
    let cutoffReason = "End of DB Forcast data";
    
    // Determine current forecast power and remaining usable sun hours (generation > base load)
    let currentForecastWatts = 0;
    if (forecastList.length > 0) {
        const nowVal = Number(forecastList[0]._value);
        currentForecastWatts = nowVal * conf.forecast_conversion_factor;
    }

    const timeStepHours = 0.25; // 0.25h = 15 min

    // Loop through forecast data to calculate total expected energy.
    // We also calculate 'remainingSunHours', but ONLY counting periods where
    // the generated power is sufficient to cover the house's base load.
    for (let point of forecastList) {
        const rawVal = Number(point._value);
        const generatedWatts = rawVal * conf.forecast_conversion_factor;
        
        if (generatedWatts < conf.base_load_w) {
            cutoffReason = `Night: PV Power < House BaseLoad`;
            break;
        }

        const stepEnergy = (generatedWatts * timeStepHours) / 1000;
        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;

        solarKwhSum += stepEnergy;
        baseLoadKwhSum += stepBaseLoad;
        remainingSunHours += timeStepHours;
    }

    
    // Factor in a margin for inefficiencies in the PV system and inverter. 
    const BATTERY_EFFICIENCY = conf.battery_efficiency;

    // Current Energy in Battery
    const currentBatteryEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;

    // Energy required to charge to 100% (including efficiency losses)
    const currentChargeEnergyKwhNeeded = (conf.battery_capacity_kwh - currentBatteryEnergyKwh) / BATTERY_EFFICIENCY;    

    // Projected Energy Outcome (Current + Gain - BaseConsumption)
    const projectedEnergyEndOfDay = currentBatteryEnergyKwh + (solarKwhSum - baseLoadKwhSum);

    // Dynamic Reserve Logic (Quadratic "Safe"):
    // We want to keep the reserve high for most of the time (safety first), 
    // and only reduce it significantly when the battery is really getting full (>70%).
    // Curve: Factor = 0.1 + 0.9 * (1 - (SoC_decimal ^ 2))
    // 
    // Examples (Formula: 0.1 + 0.9 * (1 - soc^2)):
    // 0% SoC   -> 1.00 * Reserve (100% Safety)
    // 30% SoC  -> 0.92 * Reserve (High Safety)
    // 50% SoC  -> 0.78 * Reserve
    // 80% SoC  -> 0.42 * Reserve (Risk allowed)
    // 100% SoC -> 0.10 * Reserve (10% Hard Buffer remains)
    
    const socDecimal = Math.max(0, currentSoc / 100);
    // Formula: 0.1 + (0.9 * (1 - soc^2))
    const socFactor = 0.1 + (0.9 * (1 - Math.pow(socDecimal, 2)));
    const dynamicReserve = conf.reserve_kwh * socFactor;
    
    // Target: Full Battery (with charge losses) + Reserve
    const targetEnergyEndOfDay = currentBatteryEnergyKwh + currentChargeEnergyKwhNeeded + dynamicReserve;

    // Surplus: What is left after filling battery and keeping reserve?
    const surplusKwh = projectedEnergyEndOfDay - targetEnergyEndOfDay;
    
    // Power consumption of the device in kW
    const consumerKw = conf.consumer_power_w / 1000;

    // Energy cost for one minimum runtime cycle (e.g. 1 hour run = 2kWh)
    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);

  
    // Calculate SoC needed for one cycle using the battery
    // Example: 1.5kWh needed / 10kWh Battery = 0.15 = 15% SoC needed. 
    // We divide by the battery efficiency to account for losses during discharge.
    const cycleCostSoc = (cycleCostKwh / conf.battery_capacity_kwh) * 100 /  BATTERY_EFFICIENCY;
    
    // Define the Safe Buffer Level:
    // This represents the minimum SoC we need to feel "safe" to turn on the load.
    // It is the HIGHER value of:
    // 1. The configured Hysteresis (e.g., 20% above min_soc)
    // 2. The Energy Cost of one full run cycle (e.g. 15% SoC)
    // This guarantees that if we switch ON, we have enough battery to finish the job
    // even if the sun suddenly disappears.
    const SAFE_BUFFER_SOC = Math.min(conf.min_soc + Math.max(conf.soc_hysteresis, cycleCostSoc), 100);

    debugInfo.state = "CALCULATED";
    debugInfo.current_forecast_w = currentForecastWatts;
    debugInfo.solar_gain_kwh = solarKwhSum;
    debugInfo.base_loss_kwh = baseLoadKwhSum;
    debugInfo.surplus_kwh = surplusKwh;
    debugInfo.required_cycle_kwh = cycleCostKwh;
    debugInfo.required_cycle_soc_pct = cycleCostSoc; // Show in Debug
    debugInfo.cutoff_reason = cutoffReason;
    debugInfo.remaining_sun_hours = remainingSunHours;
    debugInfo.dynamic_reserve_kwh = dynamicReserve;

    // Safety: We want at least enough sun hours for 2 full runtime cycles.
    // If we decide to run in the second-to-last cycle, there is still one cycle left to charge.
    const MIN_REMAINING_SUN_HOURS = 2 * (conf.min_runtime_minutes / 60);

    // --- DECISION LOGIC ---

    // 1. Battery CRITICAL
    if (currentSoc <= conf.min_soc) {
        if (lastState === 0) {
            lowBatLock = true; 
            debugInfo.state = "LOW_BATTERY_CRASH"; 
        } else {
            debugInfo.state = "LOW_BATTERY_IDLE"; 
        }

        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;
        switchState = 1; // OFF
        color = "red";
    }
    // 2. Battery RECOVERING (Lock Active)
    else if (lowBatLock === true) {
        reason = `Hysteresis Lock... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;
        debugInfo.state = "HYSTERESIS_LOCKED";
        switchState = 1; 
        color = "blue";
    }
    // 3. Safety Guard
    else if (remainingSunHours <=  MIN_REMAINING_SUN_HOURS) {
        switchState = 1; 
        color = "black";
        reason = `OFF. Remaining sun too short (${remainingSunHours}h <= ${MIN_REMAINING_SUN_HOURS}h)`;
        debugInfo.state = "SAFETY_GUARD_ACTIVE";
    }
    // 4. Primary Check: Is Surplus Enough?
    else if (surplusKwh >= cycleCostKwh) {
        
        // Secondary Check: "Cloud Buffer" / Instant Power Logic
        // Even if we have enough surplus for the whole day, we want to be careful 
        // about running NOW if conditions are marginal.
        //
        // Risk: If we turn ON now, but the sun is weak and the battery is low,
        // we might hit min_soc before the cycle finishes.
        //
        // Rule: Only allow switching OFF if:
        // 1. Current Solar Power is NOT enough to run the device (we are draining battery)
        // AND
        // 2. Battery is below our SAFE_BUFFER_SOC (we don't have a buffer to drain)
        if (currentForecastWatts < (conf.consumer_power_w + conf.base_load_w) && currentSoc < SAFE_BUFFER_SOC) {
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Sun & Batt Low (${currentForecastWatts.toFixed(0)}W, <${SAFE_BUFFER_SOC.toFixed(1)}%)`;
            debugInfo.state = "CURRENT_POWER_AND_SOC_LOW";
        } 
        // Switch ON if there is solar generation (Daytime).
        // This prevents draining a full battery during the night.
        else if(conf.base_load_w < currentForecastWatts){
            switchState = 0; // ON
            color = "green";
            reason = `ON. Forecast: ${currentForecastWatts.toFixed(0)}W >= Base Load: ${conf.base_load_w.toFixed(0)}W`;
            debugInfo.state = "SURPLUS_ENOUGH";
        }
        else{
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Forecast too low (${currentForecastWatts.toFixed(0)}W < ${conf.base_load_w.toFixed(0)}W)`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        }
    } 
    // 5. No Surplus
    else {
        switchState = 1; // OFF
        color = "yellow";
        if (surplusKwh > 0) {
            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        } else {
            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;
            debugInfo.state = "SURPLUS_IS_NEGATIVE";
        }
    }
}

// --- SAVE STATE ---
context.set('lowBatLock', lowBatLock);
context.set('lastState', switchState);

msg.payload = switchState;
msg.debug_calc = debugInfo;

node.status({fill: color, shape: "dot", text: reason});

return msg;