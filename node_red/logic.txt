/**
 * Control Logic for Smart Solar Consumer
 * ==========================================================
 * This logic determines if a consumer (load) should be switched ON based on:
 * 1. Current Battery SoC (State of Charge)
 * 2. Solar Forecast Data (InfluxDB)
 * 3. Calculated Energy Surplus
 * 4. Safety Constraints & Hysteresis Logic
 *
 * Inputs:
 * - msg.config: Configuration object (params like min_soc, capacity...)
 * - msg.payload: Array of InfluxDB data points (SoC + Forecast)
 * - context.lastState: Previous switch state (1=OFF, 0=ON)
 * - context.lowBatLock: Safety lock that activates if battery crashes while load is ON
 *
 * Outputs:
 * - msg.payload: 0 (ON) or 1 (OFF)
 * - msg.debug_calc: Detailed calculation info for debugging
 * - node.status: Visual ring/dot indicator
 */
if (!msg.config || !msg.config.consumer) {
    node.error("Critical Error: No configuration received!");
    node.status({fill: "red", shape: "ring", text: "Missing Config"});
    return null; 
}

// --- CONFIGURATION VALIDATION ---
function requireVal(val, name) {
    const num = Number(val);
    if (isNaN(num) || num < 0) {
        throw new Error(`Invalid value for '${name}': ${val}`);
    }
    return num;
}

const rawConf = msg.config.consumer || {};
let conf;

try {
    conf = {
        min_soc: requireVal(rawConf.min_soc, "min_soc"),
        soc_hysteresis: Number(rawConf.soc_hysteresis),
        min_runtime_minutes: requireVal(rawConf.min_runtime_minutes, "min_runtime_minutes"),
        battery_capacity_kwh: requireVal(rawConf.battery_capacity_kwh, "battery_capacity_kwh"),
        reserve_kwh: requireVal(rawConf.reserve_kwh, "reserve_kwh"),
        consumer_power_w: requireVal(rawConf.consumer_power_w, "consumer_power_w"),
        base_load_w: requireVal(rawConf.base_load_w, "base_load_w"),
        forecast_conversion_factor: requireVal(rawConf.forecast_conversion_factor, "forecast_conversion_factor")
    };
} catch (error) {
    node.error(error.message);
    node.status({fill: "grey", shape: "ring", text: "Config Error"});
    return null; 
}

// --- HYSTERESIS CONSTANTS ---
// FIX: Ensure target never exceeds 100%
const RECOVERY_SOC = Math.min(conf.min_soc + conf.soc_hysteresis, 100);

// --- LOAD CONTEXT (MEMORY) ---
// lastState: Tracks if the load was ON (0) or OFF (1) in the previous run.
// Used to detect "falling edge" events (transition from ON -> OFF).
let lastState = context.get('lastState');
if (lastState === undefined) lastState = 1; // Default: OFF (1)

// lowBatLock: A 'latch' that engages if the battery drops below min_soc while the load was active.
// It forces the load to stay OFF until the battery recovers significantly (RECOVERY_SOC).
let lowBatLock = context.get('lowBatLock');
if (lowBatLock === undefined) lowBatLock = false;

// --- EXTRACT DATA FROM INFLUX ---
let currentSoc = -1; 
let forecastList = [];
let dataValid = false;

if (Array.isArray(msg.payload)) {
    const socObj = msg.payload.find(r => r._field === "type_soc");
    if (socObj && socObj._value !== undefined) {
        currentSoc = Number(socObj._value);
    }

    forecastList = msg.payload.filter(r => 
        r._field === "type_forecast" && r._time && r._value !== null
    );

    try {
        forecastList.sort((a, b) => new Date(a._time).getTime() - new Date(b._time).getTime());
    } catch (e) {
        node.warn("Error sorting: " + e.message);
    }
    
    if (currentSoc !== -1) dataValid = true;
}

// --- UPDATE LOCK STATE (RESET) ---
// If we reached the target, release the lock immediately
if (dataValid && currentSoc >= RECOVERY_SOC) {
    lowBatLock = false;
}

// Prepare debug object
let debugInfo = {
    state: "INIT",
    soc: currentSoc,
    config_used: conf,
    low_bat_lock_active: lowBatLock,
    hysteresis_recovery_target: RECOVERY_SOC,
    solar_gain_kwh: 0,
    base_loss_kwh: 0,
    surplus_kwh: 0,
    required_cycle_kwh: 0,
    cutoff_reason: "",
    forecast_hours: 0
};

// --- LOGIC ---

let switchState = 1; // Default OFF
let reason = "";
let color = "red";

if (!dataValid) {
    reason = "Error: No Influx Data";
    color = "grey";
    debugInfo.state = "ERROR_NO_DATA";
} 
else {
    // --- CALCULATION ---
    let solarKwhSum = 0;
    let baseLoadKwhSum = 0;
    let validHours = 0;
    let cutoffReason = "End of data";
    
    const timeStepHours = 0.25; 

    for (let point of forecastList) {
        const rawVal = Number(point._value);
        const generatedWatts = rawVal * conf.forecast_conversion_factor;
        
        if (generatedWatts < conf.base_load_w) {
            cutoffReason = `Power < BaseLoad`;
            break;
        }

        const stepEnergy = (generatedWatts * timeStepHours) / 1000;
        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;

        solarKwhSum += stepEnergy;
        baseLoadKwhSum += stepBaseLoad;
        validHours += timeStepHours;
    }

    const currentEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;
    const projectedEnergy = currentEnergyKwh + (solarKwhSum - baseLoadKwhSum);
    const targetEnergy = conf.battery_capacity_kwh + conf.reserve_kwh;
    const surplusKwh = projectedEnergy - targetEnergy;
    
    const consumerKw = conf.consumer_power_w / 1000;
    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);

    debugInfo.state = "CALCULATED";
    debugInfo.solar_gain_kwh = solarKwhSum;
    debugInfo.base_loss_kwh = baseLoadKwhSum;
    debugInfo.surplus_kwh = surplusKwh;
    debugInfo.required_cycle_kwh = cycleCostKwh;
    debugInfo.cutoff_reason = cutoffReason;
    debugInfo.forecast_hours = validHours;

    const MIN_SAFE_HOURS = 2.0;

    // --- DECISION LOGIC (UPDATED) ---

    // 1. Battery CRITICAL (Below Limit)
    // -------------------------------------------------------------
    // If the battery drops below min_soc, we MUST switch off.
    // However, we only activate the "Penalty Lock" (lowBatLock) if
    // the load was actually running (lastState === 0).
    //
    // Reasoning:
    // - If load was ON: It contributed to the drain -> LOCK it to let battery recover.
    // - If load was OFF: It's just natural drain (e.g. night) -> NO LOCK, normal behavior.
    if (currentSoc <= conf.min_soc) {
        if (lastState === 0) {
            lowBatLock = true; // Activate Lock
            debugInfo.state = "LOW_BATTERY_CRASH"; 
        } else {
            debugInfo.state = "LOW_BATTERY_IDLE"; 
        }

        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;
        switchState = 1; // OFF
        color = "red";
    }
    // 2. Battery RECOVERING (Lock is active) -> Stay OFF
    // This logic now only applies if 'lowBatLock' was actually set to true above.
    else if (lowBatLock === true) {
        reason = `Hysteresis Lock... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;
        debugInfo.state = "HYSTERESIS_LOCKED";
        switchState = 1; 
        color = "blue";
    }
    // 3. Safety Guard
    else if (validHours < MIN_SAFE_HOURS) {
        switchState = 1; 
        color = "black";
        reason = `OFF. Forecast too short (${validHours}h < ${MIN_SAFE_HOURS}h)`;
        debugInfo.state = "SAFETY_GUARD_ACTIVE";
    }
    // 4. Surplus OK? -> ON
    else if (surplusKwh >= cycleCostKwh) {
        switchState = 0; // ON
        color = "green";
        reason = `ON. Surplus: ${surplusKwh.toFixed(2)} kWh`;
    } 
    // 5. No Surplus -> OFF
    else {
        switchState = 1; // OFF
        color = "orange";
        if (surplusKwh > 0) {
            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;
        } else {
            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;
        }
    }
}

// --- SAVE STATE ---
context.set('lowBatLock', lowBatLock);
context.set('lastState', switchState);

msg.payload = switchState;
msg.debug_calc = debugInfo;

node.status({fill: color, shape: "dot", text: reason});

return msg;