/**
 * Control Logic for Smart Solar Consumer
 * ==========================================================
 * This logic determines if a consumer (load) should be switched ON based on:
 * 1. Current Battery SoC (State of Charge)
 * 2. Solar Forecast Data (InfluxDB)
 * 3. Calculated Energy Surplus
 * 4. Safety Constraints & Hysteresis Logic
 *
 * Inputs:
 * - msg.config: Configuration object (params like min_soc, capacity...)
 * - msg.payload: Array of InfluxDB data points (SoC + Forecast)
 * - context.lastState: Previous switch state (1=OFF, 0=ON)
 * - context.lowBatLock: Safety lock that activates if battery crashes while load is ON
 *
 * Outputs:
 * - msg.payload: 0 (ON) or 1 (OFF)
 * - msg.debug_calc: Detailed calculation info for debugging
 * - node.status: Visual ring/dot indicator
 */
if (!msg.config || !msg.config.consumer) {
    node.error("Critical Error: No configuration received!");
    node.status({fill: "red", shape: "ring", text: "Missing Config"});
    return null; 
}

// --- CONFIGURATION VALIDATION ---
function requireVal(val, name) {
    const num = Number(val);
    if (isNaN(num) || num < 0) {
        throw new Error(`Invalid value for '${name}': ${val}`);
    }
    return num;
}

const rawConf = msg.config.consumer || {};
let conf;

try {
    conf = {
        min_soc: requireVal(rawConf.min_soc, "min_soc"),
        soc_hysteresis: Number(rawConf.soc_hysteresis),
        min_runtime_minutes: requireVal(rawConf.min_runtime_minutes, "min_runtime_minutes"),
        battery_capacity_kwh: requireVal(rawConf.battery_capacity_kwh, "battery_capacity_kwh"),
        reserve_kwh: requireVal(rawConf.reserve_kwh, "reserve_kwh"),
        consumer_power_w: requireVal(rawConf.consumer_power_w, "consumer_power_w"),
        base_load_w: requireVal(rawConf.base_load_w, "base_load_w"),
        forecast_conversion_factor: requireVal(rawConf.forecast_conversion_factor, "forecast_conversion_factor")
    };
} catch (error) {
    node.error(error.message);
    node.status({fill: "grey", shape: "ring", text: "Config Error"});
    return null; 
}

// --- HYSTERESIS CONSTANTS ---
// This is used to release the lock after a crash
const RECOVERY_SOC = Math.min(conf.min_soc + conf.soc_hysteresis, 100);

// --- LOAD CONTEXT (MEMORY) ---
let lastState = context.get('lastState');
if (lastState === undefined) lastState = 1; // Default: OFF (1)

let lowBatLock = context.get('lowBatLock');
if (lowBatLock === undefined) lowBatLock = false;

// --- EXTRACT DATA FROM INFLUX ---
let currentSoc = -1; 
let forecastList = [];
let dataValid = false;

if (Array.isArray(msg.payload)) {
    const socObj = msg.payload.find(r => r._field === "type_soc");
    if (socObj && socObj._value !== undefined) {
        currentSoc = Number(socObj._value);
    }

    forecastList = msg.payload.filter(r => 
        r._field === "type_forecast" && r._time && r._value !== null
    );

    try {
        forecastList.sort((a, b) => new Date(a._time).getTime() - new Date(b._time).getTime());
    } catch (e) {
        node.warn("Error sorting: " + e.message);
    }
    
    if (currentSoc !== -1) dataValid = true;
}

// --- UPDATE LOCK STATE (RESET) ---
if (dataValid && currentSoc >= RECOVERY_SOC) {
    lowBatLock = false;
}

// Prepare debug object
let debugInfo = {
    state: "INIT",
    soc: currentSoc,
    config_used: conf,
    low_bat_lock_active: lowBatLock,
    hysteresis_recovery_target: RECOVERY_SOC,
    current_forecast_w: 0, 
    solar_gain_kwh: 0,
    base_loss_kwh: 0,
    surplus_kwh: 0,
    required_cycle_kwh: 0,
    required_cycle_soc_pct: 0, 
    cutoff_reason: "",
    forecast_hours: 0
};

// --- LOGIC ---

let switchState = 1; // Default OFF
let reason = "";
let color = "red";

if (!dataValid) {
    reason = "Error: No Influx Data";
    color = "grey";
    debugInfo.state = "ERROR_NO_DATA";
} 
else {
    // --- CALCULATION ---
    let solarKwhSum = 0;
    let baseLoadKwhSum = 0;
    let validHours = 0;
    let cutoffReason = "End of data";
    
    // Determine the current forecast power (Now)
    let currentForecastWatts = 0;
    if (forecastList.length > 0) {
        const nowVal = Number(forecastList[0]._value);
        currentForecastWatts = nowVal * conf.forecast_conversion_factor;
    }

    const timeStepHours = 0.25; 

    for (let point of forecastList) {
        const rawVal = Number(point._value);
        const generatedWatts = rawVal * conf.forecast_conversion_factor;
        
        if (generatedWatts < conf.base_load_w) {
            cutoffReason = `Power < BaseLoad`;
            break;
        }

        const stepEnergy = (generatedWatts * timeStepHours) / 1000;
        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;

        solarKwhSum += stepEnergy;
        baseLoadKwhSum += stepBaseLoad;
        validHours += timeStepHours;
    }

    const currentEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;
    const projectedEnergy = currentEnergyKwh + (solarKwhSum - baseLoadKwhSum);
    const targetEnergy = conf.battery_capacity_kwh + conf.reserve_kwh;
    const surplusKwh = projectedEnergy - targetEnergy;
    
    const consumerKw = conf.consumer_power_w / 1000;
    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);

    // Calculate SoC needed for one cycle
    // Example: 1.5kWh needed / 10kWh Battery = 0.15 = 15% SoC needed
    const cycleCostSoc = (cycleCostKwh / conf.battery_capacity_kwh) * 100;
    
    // Define the Safe Buffer Level: 
    // We use the MAXIMUM of either the Hysteresis Setting OR the Calculated Cycle Cost.
    // This ensures we always have enough juice for at least one run.
    const SAFE_BUFFER_SOC = Math.min(conf.min_soc + Math.max(conf.soc_hysteresis, cycleCostSoc), 100);

    debugInfo.state = "CALCULATED";
    debugInfo.current_forecast_w = currentForecastWatts;
    debugInfo.solar_gain_kwh = solarKwhSum;
    debugInfo.base_loss_kwh = baseLoadKwhSum;
    debugInfo.surplus_kwh = surplusKwh;
    debugInfo.required_cycle_kwh = cycleCostKwh;
    debugInfo.required_cycle_soc_pct = cycleCostSoc; // Show in Debug
    debugInfo.cutoff_reason = cutoffReason;
    debugInfo.forecast_hours = validHours;

    const MIN_SAFE_HOURS = 2.0;

    // --- DECISION LOGIC ---

    // 1. Battery CRITICAL
    if (currentSoc <= conf.min_soc) {
        if (lastState === 0) {
            lowBatLock = true; 
            debugInfo.state = "LOW_BATTERY_CRASH"; 
        } else {
            debugInfo.state = "LOW_BATTERY_IDLE"; 
        }

        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;
        switchState = 1; // OFF
        color = "red";
    }
    // 2. Battery RECOVERING (Lock Active)
    else if (lowBatLock === true) {
        reason = `Hysteresis Lock... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;
        debugInfo.state = "HYSTERESIS_LOCKED";
        switchState = 1; 
        color = "blue";
    }
    // 3. Safety Guard
    else if (validHours < MIN_SAFE_HOURS) {
        switchState = 1; 
        color = "black";
        reason = `OFF. Forecast too short (${validHours}h < ${MIN_SAFE_HOURS}h)`;
        debugInfo.state = "SAFETY_GUARD_ACTIVE";
    }
    // 4. Primary Check: Is Surplus Enough?
    else if (surplusKwh >= cycleCostKwh) {
        
        // Secondary Check: "Cloud Buffer" Logic
        // We only switch OFF if Sun is low AND Battery Buffer is insufficient.
        // We use SAFE_BUFFER_SOC here to guarantee we can survive the min_runtime.
        if (currentForecastWatts < (conf.consumer_power_w + conf.base_load_w) && currentSoc < SAFE_BUFFER_SOC) {
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Sun & Batt Low (${currentForecastWatts.toFixed(0)}W, <${SAFE_BUFFER_SOC.toFixed(1)}%)`;
            debugInfo.state = "CURRENT_POWER_AND_SOC_LOW";
        } 
        // Switch ON if Forecast is at least as high as Base Load
        else if(conf.base_load_w < currentForecastWatts){
            switchState = 0; // ON
            color = "green";
            reason = `ON. Forecast: ${currentForecastWatts.toFixed(0)}W >= Base Load: ${conf.base_load_w.toFixed(0)}W`;
            debugInfo.state = "SURPLUS_ENOUGH";
        }
        else{
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Forecast too low (${currentForecastWatts.toFixed(0)}W < ${conf.base_load_w.toFixed(0)}W)`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        }
    } 
    // 5. No Surplus
    else {
        switchState = 1; // OFF
        color = "yellow";
        if (surplusKwh > 0) {
            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        } else {
            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;
            debugInfo.state = "SURPLUS_IS_NEGATIVE";
        }
    }
}

// --- SAVE STATE ---
context.set('lowBatLock', lowBatLock);
context.set('lastState', switchState);

msg.payload = switchState;
msg.debug_calc = debugInfo;

node.status({fill: color, shape: "dot", text: reason});

return msg;