/**
 * CONTROL LOGIC (Direct Config + Safety Guard + Hysteresis)
 * Expects msg.config.consumer from Template Node
 */

// Safety check: Only check IF config exists
if (!msg.config || !msg.config.consumer) {
    node.error("Critical Error: No configuration received!");
    node.status({fill: "red", shape: "ring", text: "Missing Config"});
    return null; 
}

// We use the config object directly as the source of truth
const conf = msg.config.consumer;

// --- HYSTERESIS CONSTANTS ---
const SOC_HYSTERESIS = 20.0; // Battery must charge 20% above min_soc before restarting
const RECOVERY_SOC = conf.min_soc + SOC_HYSTERESIS;

// --- LOAD CONTEXT (MEMORY) ---
// We need to know if we were last ON or OFF
let lastState = context.get('lastState');
if (lastState === undefined) lastState = 1; // Default: OFF (1)

// --- EXTRACT DATA FROM INFLUX ---
let currentSoc = -1; 
let forecastList = [];
let dataValid = false;

if (Array.isArray(msg.payload)) {
    // 1. Find SoC
    const socObj = msg.payload.find(r => r._field === "type_soc");
    if (socObj && socObj._value !== undefined && socObj._value !== null) {
        currentSoc = Number(socObj._value);
    }

    // 2. Filter forecast list
    forecastList = msg.payload.filter(r => 
        r._field === "type_forecast" && r._time && r._value !== null
    );

    // 3. Sort by time
    try {
        forecastList.sort((a, b) => new Date(a._time).getTime() - new Date(b._time).getTime());
    } catch (e) {
        node.warn("Error sorting: " + e.message);
    }
    
    // Validation: We need at least the SoC
    if (currentSoc !== -1) dataValid = true;
}

// --- INITIALIZATION ---

let switchState = 1; // Standard: OFF
let reason = "";
let color = "red";

// Prepare debug object (fully initialized)
let debugInfo = {
    state: "INIT",
    soc: currentSoc,
    config_used: conf,
    last_state_mem: lastState, 
    hysteresis_recovery_target: RECOVERY_SOC,
    // Placeholders for calculated values
    solar_gain_kwh: 0,
    base_loss_kwh: 0,
    surplus_kwh: 0,
    required_cycle_kwh: 0,
    cutoff_reason: "",
    forecast_hours: 0
};

// --- LOGIC ---

if (!dataValid) {
    reason = "Error: No Influx Data";
    color = "grey";
    debugInfo.state = "ERROR_NO_DATA";
    switchState = 1; 
} 
else {
    // --- CALCULATION ---
    let solarKwhSum = 0;
    let baseLoadKwhSum = 0;
    let validHours = 0;
    let cutoffReason = "End of data";
    
    const timeStepHours = 0.25; // Corresponds to Influx Window 15m

    for (let point of forecastList) {
        const rawVal = Number(point._value);
        // Direct access to conf.forecast_conversion_factor
        const generatedWatts = rawVal * conf.forecast_conversion_factor;
        
        // Abort: Generation < Base load (conf.base_load_w)
        if (generatedWatts < conf.base_load_w) {
            cutoffReason = `Power < BaseLoad`;
            break;
        }

        const stepEnergy = (generatedWatts * timeStepHours) / 1000;
        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;

        solarKwhSum += stepEnergy;
        baseLoadKwhSum += stepBaseLoad;
        validHours += timeStepHours;
    }

    // Balancing with config values
    const currentEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;
    const projectedEnergy = currentEnergyKwh + (solarKwhSum - baseLoadKwhSum);
    const targetEnergy = conf.battery_capacity_kwh + conf.reserve_kwh;
    const surplusKwh = projectedEnergy - targetEnergy;
    
    // Calculate cost for minimum runtime
    const consumerKw = conf.consumer_power_w / 1000;
    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);

    // Fill debug infos
    debugInfo.state = "CALCULATED";
    debugInfo.solar_gain_kwh = solarKwhSum;
    debugInfo.base_loss_kwh = baseLoadKwhSum;
    debugInfo.surplus_kwh = surplusKwh;
    debugInfo.required_cycle_kwh = cycleCostKwh;
    debugInfo.cutoff_reason = cutoffReason;
    debugInfo.forecast_hours = validHours;

    const MIN_SAFE_HOURS = 2.0;

    // --- DECISION WITH HYSTERESIS ---

    // 1. Battery is critically low -> IMMEDIATELY OFF
    if (currentSoc <= conf.min_soc) {
        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;
        debugInfo.state = "LOW_BATTERY_CUTOFF";
        switchState = 1; // OFF
        color = "red";
    }
    // 2. Battery is in "recovery phase" (hysteresis)
    // If we were OFF (lastState === 1) AND have not yet reached the recovery target
    else if (lastState === 1 && currentSoc < RECOVERY_SOC) {
        reason = `Charging... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;
        debugInfo.state = "HYSTERESIS_RECOVERY";
        switchState = 1; // Remains OFF
        color = "blue"; // Blue for "Waiting/Charging"
    }
    // 3. Safety guard: Data incomplete?
    else if (validHours < MIN_SAFE_HOURS) {
        switchState = 1; // OFF
        color = "black";
        reason = `OFF. Forecast too short (${validHours}h < ${MIN_SAFE_HOURS}h)`;
        debugInfo.state = "SAFETY_GUARD_ACTIVE";
    }
    // 4. Normal logic (Enough surplus?)
    else if (surplusKwh >= cycleCostKwh) {
        switchState = 0; // ON
        color = "green";
        reason = `ON. Surplus: ${surplusKwh.toFixed(2)} kWh`;
    } 
    // 5. Too little surplus
    else {
        switchState = 1; // OFF
        color = "orange";
        if (surplusKwh > 0) {
            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;
        } else {
            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;
        }
    }
}

// --- SAVE STATUS & OUTPUT ---

// We save the new status for the next run
context.set('lastState', switchState);

msg.payload = switchState;
msg.debug_calc = debugInfo;

node.status({fill: color, shape: "dot", text: reason});

return msg;