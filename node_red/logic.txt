/**
 * Control Logic for Smart Solar Consumer
 * ==========================================================
 * This logic determines if a consumer (load) should be switched ON based on:
 * 1. Current Battery SoC (State of Charge)
 * 2. Solar Forecast Data (InfluxDB)
 * 3. Calculated Energy Surplus
 * 4. Safety Constraints & Hysteresis Logic
 *
 * Inputs:
 * - msg.config: Configuration object (params like min_soc, capacity...)
 * - msg.payload: Array of InfluxDB data points (SoC + Forecast + Production)
 * - context.lastState: Previous switch state (1=OFF, 0=ON)
 * - context.lowBatLock: Safety lock that activates if battery crashes while load is ON
 *
 * Outputs:
 * - msg.payload: 0 (ON) or 1 (OFF)
 * - msg.debug_calc: Detailed calculation info for debugging
 * - node.status: Visual ring/dot indicator
 */
if (!msg.config || !msg.config.consumer) {
    node.error("Critical Error: No configuration received!");
    node.status({fill: "red", shape: "ring", text: "Missing Config"});
    return null; 
}

// --- CONFIGURATION VALIDATION ---
function requireVal(val, name) {
    const num = Number(val);
    if (isNaN(num) || num < 0) {
        throw new Error(`Invalid value for '${name}': ${val}`);
    }
    return num;
}

const rawConf = msg.config.consumer || {};
let conf;

try {
    conf = {
        min_soc: requireVal(rawConf.min_soc, "min_soc"),
        soc_hysteresis: Number(rawConf.soc_hysteresis),
        min_runtime_minutes: requireVal(rawConf.min_runtime_minutes, "min_runtime_minutes"),
        battery_capacity_kwh: requireVal(rawConf.battery_capacity_kwh, "battery_capacity_kwh"),
        pv_peak_power_w: requireVal(rawConf.pv_peak_power_w, "pv_peak_power_w"),
        reserve_kwh: requireVal(rawConf.reserve_kwh, "reserve_kwh"),
        consumer_power_w: requireVal(rawConf.consumer_power_w, "consumer_power_w"),
        base_load_w: requireVal(rawConf.base_load_w, "base_load_w"),
        battery_efficiency: requireVal(rawConf.battery_efficiency, "battery_efficiency"),
        use_damping_factor: rawConf.use_damping_factor !== undefined ? Boolean(rawConf.use_damping_factor) : false,
        allow_battery_support: rawConf.allow_battery_support !== undefined ? Boolean(rawConf.allow_battery_support) : true
    };
} catch (error) {
    node.error(error.message);
    node.status({fill: "grey", shape: "ring", text: "Config Error"});
    return null; 
}

// --- HYSTERESIS CONSTANTS ---
// This is used to release the lock after a batterie crash
const RECOVERY_SOC = Math.min(conf.min_soc + conf.soc_hysteresis, 100);

// --- LOAD CONTEXT (MEMORY) ---
let lastState = context.get('lastState');
if (lastState === undefined) lastState = 1; // Default: OFF (1)

let lowBatLock = context.get('lowBatLock');
if (lowBatLock === undefined) lowBatLock = false;

// --- EXTRACT DATA FROM INFLUX ---
let currentSoc = -1; 
let fullForecastList = [];
let productionList = [];
let dataValid = false;

if (Array.isArray(msg.payload)) {
    const socObj = msg.payload.find(r => r._field === "type_soc");
    if (socObj && socObj._value !== undefined) {
        currentSoc = Number(socObj._value);
    }

    fullForecastList = msg.payload.filter(r => 
        r._field === "type_forecast" && r._time && r._value !== null
    );
    
    // Extract Actual Production (History) for Damping Calculation
    productionList = msg.payload.filter(r => 
        r._field === "type_production" && r._time && r._value !== null
    );

    try {
        const timeSort = (a, b) => new Date(a._time).getTime() - new Date(b._time).getTime();
        fullForecastList.sort(timeSort);
        productionList.sort(timeSort);
    } catch (e) {
        node.warn("Error sorting: " + e.message);
    }
    
    if (currentSoc !== -1) dataValid = true;
}

// --- UPDATE LOCK STATE (RESET) ---
if (dataValid && currentSoc >= RECOVERY_SOC) {
    lowBatLock = false;
}

// --- DAMPING FACTOR CALCULATION ---
// Concept: "Real-Time Forecast Correction"
// We compare the ACTUAL production vs. the FORECAST since sunrise to calculate a "Performance Factor".
// If the sun is stronger than predicted (Factor > 1.0), we scale UP the future forecast.
// If it is cloudier than predicted (Factor < 1.0), we scale DOWN the future forecast.
// This allows the system to react dynamically to intraday weather changes (e.g. fog clearing up earlier).
const nowMs = Date.now();
let dampingFactor = 1.0;
let sumForecastPast = 0;
let sumProductionPast = 0;

let dampingReason = "OK";
let matchCount = 0;

if (conf.use_damping_factor) {
    if (productionList.length > 0 && fullForecastList.length > 0) {
        for (let prod of productionList) {
            const pTime = new Date(prod._time).getTime();
            if (pTime > nowMs) continue; // Skip future

            // Find matching forecast (within 7.5 mins)
            const match = fullForecastList.find(f => Math.abs(new Date(f._time).getTime() - pTime) < 7.5 * 60 * 1000);
            
            if (match) {
                const fVal = Number(match._value);
                const pVal = Number(prod._value); // Assumed Watts
                
                // Only compare when significant power is expected (> 50% of Base Load)
                // This implicitly filters for "since sunrise"
                if (fVal > conf.base_load_w / 2.0) { 
                     sumForecastPast += fVal;
                     sumProductionPast += pVal;
                     matchCount++;
                }
            }
        }

        // Only apply if we have enough accumulated sun-hours data. 8 samples needed for 2 h. 
        if (sumForecastPast >  conf.base_load_w  / 2.0 * 8.0) { 
            dampingFactor = sumProductionPast / sumForecastPast;
            // Safety Clamping (0.75x to 1.5x) to prevent extreme scaling
            dampingFactor = Math.max(0.75, Math.min(dampingFactor, 1.5));
        } else {
            dampingReason = "Insufficient Sun-Hours (Sums too low)";
        }
    } else {
        if (productionList.length === 0 && fullForecastList.length === 0) dampingReason = "No Data (Prod & Fcst)";
        else if (productionList.length === 0) dampingReason = "No Production Data";
        else if (fullForecastList.length === 0) dampingReason = "No Forecast Data";
    }
} else {
    dampingReason = "Disabled by Config";
}

// --- FILTER & ADJUST FORECAST ---
// 1. Keep only FUTURE items for planning (from now onwards)
// 2. Apply Damping Factor
let forecastList = [];
let currentForecastWatts = 0;

if (fullForecastList.length > 0) {
    // Include current 15-min window
    const activeWindowStart = nowMs - (15 * 60 * 1000);
    
    forecastList = fullForecastList
        .filter(f => new Date(f._time).getTime() >= activeWindowStart)
        .map(item => {
            // Apply Damping Factor with Time Decay
            // Formula: Weight = 0.5 ^ (hours_future / 2)
            // Meaning: 100% influence now, 50% in 2h, 25% in 4h, ...
            let adjustedForecastValue = Number(item._value);
            
            if (conf.use_damping_factor) {
                 const itemTime = new Date(item._time).getTime();
                 
                 // Difference in hours between NOW and this future forecast point
                 // (Math.max to ensure we don't handle negative past times weirdly, although they are filtered)
                 const diffHours = Math.max(0, (itemTime - nowMs) / (1000 * 60 * 60));
                 
                 // --- TIME DECAY LOGIC ---
                 // We trust the current deviation (Damping Factor) fully for the immediate moment.
                 // However, weather anomalies (clouds, fog) are often temporary.
                 // We don't want to scale the forecast 10 hours away based on a cloud right now.
                 //
                 // Formula: Weight = 0.5 ^ (hours / 1.0)
                 // This is an "Exponential Decay" with a Half-Life of 1 hour.
                 // - T+0h: Weight 100% -> Full influence of Damping Factor
                 // - T+1h: Weight  50% -> Half influence
                 // - T+2h: Weight  25% -> Quarter influence
                 // - T+4h: Weight   6% -> Nearly back to original Forecast (1.0)
                 const decayWeight = Math.pow(0.5, diffHours / 1.0);
                 
                 // Calculate Effective Factor for this specific time point
                 // We blend the calculated "dampingFactor" with standard "1.0" based on the weight.
                 const effectiveFactor = 1.0 + ((dampingFactor - 1.0) * decayWeight);
                 
                 // Limit the scaled value to the physical maximum of the PV system
                 adjustedForecastValue = Math.min(adjustedForecastValue * effectiveFactor, conf.pv_peak_power_w);
            }
            
            return { ...item, _value: adjustedForecastValue };
        });

    if (forecastList.length > 0) {
        currentForecastWatts = Number(forecastList[0]._value);
    }
}

// Prepare debug object
let debugInfo = {
    state: "INIT",
    soc: currentSoc,
    config_used: conf,
    low_bat_lock_active: lowBatLock,
    hysteresis_recovery_target: RECOVERY_SOC,
    current_forecast_w: currentForecastWatts, 
    damping_factor: dampingFactor.toFixed(2),
    past_analysis: `Matches:${matchCount} | Prod:${sumProductionPast.toFixed(0)} vs Fcst:${sumForecastPast.toFixed(0)} (${dampingReason})`,
    solar_gain_kwh: 0,
    base_loss_kwh: 0,
    surplus_kwh: 0,
    required_cycle_kwh: 0,
    required_cycle_soc_pct: 0, 
    cutoff_reason: "",
    remaining_sun_hours: 0
};

// --- LOGIC ---

let switchState = 1; // Default OFF
let reason = "";
let color = "red";

if (!dataValid) {
    reason = "Error: No Influx Data";
    color = "grey";
    debugInfo.state = "ERROR_NO_DATA";
} 
else {
    // --- CALCULATION ---
    let solarKwhSum = 0;
    let baseLoadKwhSum = 0;
    let remainingSunHours = 0;
    let cutoffReason = "End of DB Forcast data";
    
    // Determine current forecast power and remaining usable sun hours (generation > base load)
    // const timeStepHours = 0.25; // 0.25h = 15 min // This line was moved from here
    
    const timeStepHours = 0.25; // 0.25h = 15 min

    // Loop through forecast data to calculate total expected energy.
    // We also calculate 'remainingSunHours', but ONLY counting periods where
    // the generated power is sufficient to cover the house's base load.
    for (let point of forecastList) {
        const rawVal = Number(point._value);
        const generatedWatts = Number(point._value);
        
        if (generatedWatts < conf.base_load_w) {
            cutoffReason = `Night: PV Power < House BaseLoad`;
            break;
        }

        const stepEnergy = (generatedWatts * timeStepHours) / 1000;
        const stepBaseLoad = (conf.base_load_w * timeStepHours) / 1000;

        solarKwhSum += stepEnergy;
        baseLoadKwhSum += stepBaseLoad;
        remainingSunHours += timeStepHours;
    }

    
    // Factor in a margin for inefficiencies in the PV system and inverter. 
    const BATTERY_EFFICIENCY = conf.battery_efficiency;

    // Current Energy in Battery
    const currentBatteryEnergyKwh = (currentSoc / 100) * conf.battery_capacity_kwh;

    // Energy required to charge to 100% (including efficiency losses)
    const currentChargeEnergyKwhNeeded = (conf.battery_capacity_kwh - currentBatteryEnergyKwh) / BATTERY_EFFICIENCY;    

    // Projected Energy Outcome (Current + Gain - BaseConsumption)
    const projectedEnergyEndOfDay = currentBatteryEnergyKwh + (solarKwhSum - baseLoadKwhSum);

    // Dynamic Reserve Logic (Quadratic "Safe"):
    // We want to keep the reserve high for most of the time (safety first), 
    // and only reduce it significantly when the battery is really getting full (>70%).
    // Curve: Factor = 0.1 + 0.9 * (1 - (SoC_decimal ^ 2))
    // 
    // Examples (Formula: 0.1 + 0.9 * (1 - soc^2)):
    // 0% SoC   -> 1.00 * Reserve (100% Safety)
    // 30% SoC  -> 0.92 * Reserve (High Safety)
    // 50% SoC  -> 0.78 * Reserve
    // 80% SoC  -> 0.42 * Reserve (Risk allowed)
    // 100% SoC -> 0.10 * Reserve (10% Hard Buffer remains)
    
    const socDecimal = Math.max(0, currentSoc / 100);
    // Formula: 0.1 + (0.9 * (1 - soc^2))
    const socFactor = 0.1 + (0.9 * (1 - Math.pow(socDecimal, 2)));
    const dynamicReserve = conf.reserve_kwh * socFactor;
    
    // Target: Full Battery (with charge losses) + Reserve
    const targetEnergyEndOfDay = currentBatteryEnergyKwh + currentChargeEnergyKwhNeeded + dynamicReserve;

    // Surplus: What is left after filling battery and keeping reserve?
    const surplusKwh = projectedEnergyEndOfDay - targetEnergyEndOfDay;
    
    // Power consumption of the device in kW
    const consumerKw = conf.consumer_power_w / 1000;

    // Energy cost for one minimum runtime cycle (e.g. 1 hour run = 2kWh)
    const cycleCostKwh = consumerKw * (conf.min_runtime_minutes / 60);

  
    // Calculate SoC needed for one cycle using the battery
    // Example: 1.5kWh needed / 10kWh Battery = 0.15 = 15% SoC needed. 
    // We divide by the battery efficiency to account for losses during discharge.
    const cycleCostSoc = (cycleCostKwh / conf.battery_capacity_kwh) * 100 /  BATTERY_EFFICIENCY;
    
    // Define the Safe Buffer Level:
    // This represents the minimum SoC we need to feel "safe" to turn on the load.
    // It is the HIGHER value of:
    // 1. The configured Hysteresis (e.g., 20% above min_soc)
    // 2. The Energy Cost of one full run cycle (e.g. 15% SoC)
    // This guarantees that if we switch ON, we have enough battery to finish the job
    // even if the sun suddenly disappears.
    // This guarantees that if we switch ON, we have enough battery to finish the job
    // even if the sun suddenly disappears.
    // If support is disabled, we only need the hysteresis buffer.
    const neededBuffer = conf.allow_battery_support ? Math.max(conf.soc_hysteresis, cycleCostSoc) : conf.soc_hysteresis;
    const requiredSafeBufferSoc = conf.min_soc + neededBuffer;
    
    if (requiredSafeBufferSoc > 100) {
        const err = `Safety Buffer ${requiredSafeBufferSoc.toFixed(1)}% > 100%. Battery too small for consumer_power/min_runtime!`;
        node.error(err);
        node.status({fill: "red", shape: "ring", text: "Config: Battery too small"});
        return null; 
    }

    const SAFE_BUFFER_SOC = requiredSafeBufferSoc;

    debugInfo.state = "CALCULATED";
    debugInfo.current_forecast_w = currentForecastWatts;
    debugInfo.solar_gain_kwh = solarKwhSum;
    debugInfo.base_loss_kwh = baseLoadKwhSum;
    debugInfo.surplus_kwh = surplusKwh;
    debugInfo.required_cycle_kwh = cycleCostKwh;
    debugInfo.required_cycle_soc_pct = cycleCostSoc; // Show in Debug
    debugInfo.cutoff_reason = cutoffReason;
    debugInfo.remaining_sun_hours = remainingSunHours;
    debugInfo.dynamic_reserve_kwh = dynamicReserve;

    // Safety: We want at least enough sun hours for 2 full runtime cycles.
    // If we decide to run in the second-to-last cycle, there is still one cycle left to charge.
    const MIN_REMAINING_SUN_HOURS = 2 * (conf.min_runtime_minutes / 60);

    // --- DECISION LOGIC ---

    // 1. Battery CRITICAL
    if (currentSoc <= conf.min_soc) {
        if (lastState === 0) {
            lowBatLock = true; 
            debugInfo.state = "LOW_BATTERY_CRASH"; 
        } else {
            debugInfo.state = "LOW_BATTERY_IDLE"; 
        }

        reason = `Low Battery (${currentSoc.toFixed(1)}% <= ${conf.min_soc}%)`;
        switchState = 1; // OFF
        color = "red";
    }
    // 2. Battery RECOVERING (Lock Active)
    else if (lowBatLock === true) {
        reason = `Hysteresis Lock... Wait for ${RECOVERY_SOC}% (curr: ${currentSoc.toFixed(1)}%)`;
        debugInfo.state = "HYSTERESIS_LOCKED";
        switchState = 1; 
        color = "blue";
    }
    // 3. Safety Guard
    else if (remainingSunHours <=  MIN_REMAINING_SUN_HOURS) {
        switchState = 1; 
        color = "black";
        reason = `OFF. Remaining sun too short (${remainingSunHours}h <= ${MIN_REMAINING_SUN_HOURS}h)`;
        debugInfo.state = "SAFETY_GUARD_ACTIVE";
    }
    // 4. Primary Check: Is Surplus Enough?
    else if (surplusKwh >= cycleCostKwh) {
        
        // Secondary Check: "Cloud Buffer" / Instant Power Logic
        // Even if we have enough surplus for the whole day, we want to be careful 
        // about running NOW if conditions are marginal.
        //
        // Risk: If we turn ON now, but the sun is weak and the battery is low,
        // we might hit min_soc before the cycle finishes.
        //
        // Rule: Only allow switching OFF if:
        // Current Solar Power is NOT enough to run the device (we are draining battery)
        // AND
        // Battery is below our SAFE_BUFFER_SOC (we don't have a buffer to drain)
        if (conf.allow_battery_support && currentForecastWatts < (conf.consumer_power_w + conf.base_load_w) && currentSoc < SAFE_BUFFER_SOC) {
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Filling Battery (${currentForecastWatts.toFixed(0)}W, ${currentSoc.toFixed(1)}% < ${SAFE_BUFFER_SOC.toFixed(1)}%)`;
            debugInfo.state = "CURRENT_POWER_AND_SOC_LOW";
        } 
        // Do we have enough power for EVERYTHING (Base + Consumer)?
        else if((conf.base_load_w + conf.consumer_power_w) < currentForecastWatts){
            switchState = 0; // ON
            color = "green";
            // If the forecast is higher than the base load + consumer power, we can switch ON
            reason = `ON. Full Power: ${currentForecastWatts.toFixed(0)}W >= ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W`;
            debugInfo.state = "SURPLUS_ENOUGH";
        }
        // Do we have at least enough for Base Load? (Draining battery for consumer)
        else if(conf.base_load_w < currentForecastWatts){
            if (conf.allow_battery_support) {
                switchState = 0; // ON
                color = "green";
                // If the forecast is higher than the base load, we can switch ON
                reason = `ON. Battery Support: ${currentForecastWatts.toFixed(0)}W < ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W`;
                debugInfo.state = "SURPLUS_DRAINING";
            } else {
                switchState = 1; // OFF
                color = "yellow";
                reason = `OFF. Battery Support Disabled (${currentForecastWatts.toFixed(0)}W < ${(conf.base_load_w + conf.consumer_power_w).toFixed(0)}W)`;
                debugInfo.state = "BATTERY_SUPPORT_DISABLED";
            }
        }
        else{
            switchState = 1; // OFF
            color = "yellow";
            reason = `OFF. Forecast too low (${currentForecastWatts.toFixed(0)}W < ${conf.base_load_w.toFixed(0)}W)`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        }
    } 
    // 5. No Surplus
    else {
        switchState = 1; // OFF
        color = "yellow";
        if (surplusKwh > 0) {
            reason = `OFF. Surplus too low (${surplusKwh.toFixed(2)} < ${cycleCostKwh.toFixed(2)})`;
            debugInfo.state = "SURPLUS_TOO_LOW";
        } else {
            reason = `OFF. Deficit: ${Math.abs(surplusKwh).toFixed(2)} kWh`;
            debugInfo.state = "SURPLUS_IS_NEGATIVE";
        }
    }
}

// --- SAVE STATE ---
context.set('lowBatLock', lowBatLock);
context.set('lastState', switchState);

msg.payload = switchState;
msg.debug_calc = debugInfo;

node.status({fill: color, shape: "dot", text: reason});

return msg;